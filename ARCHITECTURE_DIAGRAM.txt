================================================================================
                    CORTEX ADAPTER SYSTEM - VISUAL ARCHITECTURE
================================================================================

LAYER STACK (High → Low Level):
┌─────────────────────────────────────────────────────────────────────────────┐
│ Application Layer (Handshake & Window Processing)                           │
│ ├─ Harness: cortex run --kernel car                                         │
│ ├─ Adapter: primitives/adapters/v1/native/cortex_adapter_native             │
│ └─ Protocol: HELLO → CONFIG → ACK → [WINDOW_CHUNK → RESULT]* → ERROR        │
├─────────────────────────────────────────────────────────────────────────────┤
│ Protocol Layer (Frame-Based Communication)                                  │
│ ├─ MAGIC Hunting: 0x43525458 ("CRTX") in byte stream                       │
│ ├─ Frame Header: 16 bytes (magic, version, type, length, CRC32)            │
│ ├─ CRC Validation: crc32(header[0:12] + payload)                           │
│ └─ Chunking: 8KB chunks for windows > 8KB                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│ Transport Layer (Byte-Stream Abstraction)                                   │
│ ├─ Mock (local://): POSIX socketpair, poll() timeout [PRODUCTION]           │
│ ├─ TCP Client (tcp://host:port): Network connection [PRODUCTION]            │
│ ├─ TCP Server (tcp://:port): Listen mode for adapter                        │
│ └─ UART/Serial (serial:///dev/ttyUSB0): Hardware serial, 11 KB/s            │
└─────────────────────────────────────────────────────────────────────────────┘

================================================================================
                          DATA FLOW: LOCAL EXECUTION
================================================================================

User Input:
  $ cortex run --kernel car

┌──────────────────────────────────────────────────────────────────────────────┐
│ HARNESS PROCESS (Measurement Orchestrator)                                   │
│                                                                              │
│  1. Parse Arguments & Load Config                                           │
│     └─ dataset_path, window_size=160, hop=80, channels=64                   │
│                                                                              │
│  2. device_comm_init() [lines 359-548]                                      │
│     ├─ spawn_adapter() [lines 49-127]                                       │
│     │  ├─ socketpair(AF_UNIX) → [harness_fd, adapter_fd]                   │
│     │  ├─ fork() → adapter_pid                                              │
│     │  ├─ (child) dup2(adapter_fd → stdin/stdout)                           │
│     │  ├─ (child) exec("cortex_adapter_native")                             │
│     │  └─ (parent) store harness_fd, adapter_pid                            │
│     │                                                                        │
│     └─ Create transport:                                                     │
│        └─ cortex_transport_mock_create(harness_fd)                          │
│                                                                              │
│  3. HANDSHAKE PHASE (atomic, synchronous)                                   │
│                                                                              │
│     STEP 1: recv_hello() [lines 170-234]                                    │
│     ├─ Hunt MAGIC, read header, verify CRC                                  │
│     └─ Extract: boot_id, adapter_name, device_info                          │
│                                                                              │
│     STEP 2: send_config() [lines 243-286]                                   │
│     ├─ Generate session_id (random)                                         │
│     ├─ Build payload: W, H, C, kernel_name, params                          │
│     ├─ Include calibration_state (if trainable)                             │
│     └─ Send CONFIG frame                                                     │
│                                                                              │
│     STEP 3: recv_ack() [lines 298-351]                                      │
│     ├─ Extract actual output dimensions (W_out, C_out)                       │
│     └─ Return cortex_device_init_result_t                                    │
│                                                                              │
│  4. EXECUTION LOOP (for each hop)                                           │
│     │                                                                        │
│     ├─ Replayer pulls window (160×64 samples, 40,960 bytes)                 │
│     │                                                                        │
│     ├─ device_comm_execute_window() [lines 553-664]                         │
│     │  │                                                                     │
│     │  ├─ SEND: cortex_protocol_send_window_chunked()                       │
│     │  │   ├─ Split into 8KB chunks (5 chunks for 40KB window)              │
│     │  │   └─ Send WINDOW_CHUNK frame for each chunk                        │
│     │  │       └─ [sequence, total_bytes, offset, length, flags, samples]   │
│     │  │                                                                     │
│     │  ├─ RECEIVE: cortex_protocol_recv_frame()                             │
│     │  │   ├─ Hunt MAGIC, read header, read payload                         │
│     │  │   ├─ Verify CRC32                                                  │
│     │  │   └─ Parse RESULT payload (session_id, sequence, timing, output)    │
│     │  │                                                                     │
│     │  └─ Store: latency distribution + timing metadata                     │
│     │                                                                        │
│     └─ Continue until dataset exhausted                                      │
│                                                                              │
│  5. CLEANUP (device_comm_teardown)                                          │
│     ├─ Close transport (adapter detects EOF)                                │
│     ├─ waitpid(adapter_pid) [reap zombie]                                   │
│     └─ Generate results (plots, reports)                                     │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
                                      │
                    [socketpair bidirectional IPC]
                                      │
                                      ▼
┌──────────────────────────────────────────────────────────────────────────────┐
│ ADAPTER PROCESS (Kernel Runner)                                              │
│                                                                              │
│  1. Inherit stdin/stdout from socketpair (connected by parent)              │
│                                                                              │
│  2. Create transport from stdin/stdout                                       │
│     └─ cortex_transport_mock_create_from_fds(STDIN, STDOUT)                │
│                                                                              │
│  3. run_session() [lines 237+]                                              │
│                                                                              │
│     STEP 1: Send HELLO [cortex_adapter_send_hello()]                        │
│     ├─ boot_id (random, detects restarts)                                   │
│     ├─ adapter_name, supported_kernels                                      │
│     ├─ device_hostname, device_cpu, device_os                               │
│     └─ Serialize to little-endian, send frame                               │
│                                                                              │
│     STEP 2: Receive CONFIG [cortex_adapter_recv_config()]                   │
│     ├─ Parse payload (W, H, C, kernel_name, params)                         │
│     ├─ Extract calibration_state (malloc if present)                        │
│     └─ Return all parameters                                                │
│                                                                              │
│     STEP 3: Load kernel plugin [load_kernel_plugin, lines 102-215]          │
│     ├─ Parse spec_uri: "primitives/kernels/v1/car@f32"                     │
│     ├─ Build lib path: "primitives/kernels/v1/car@f32/libcar.dylib"         │
│     ├─ dlopen(lib_path)                                                      │
│     ├─ dlsym(cortex_init, cortex_process, cortex_teardown)                  │
│     ├─ dlsym(cortex_calibrate) [detect ABI v2 vs v3]                        │
│     │   └─ if (calibrate_fn != NULL) abi_version = 3 else 2                │
│     └─ cortex_init(&config)                                                 │
│         ├─ Allocate state buffers                                            │
│         ├─ Validate parameters                                              │
│         ├─ Load calibration_state (trainable kernels)                        │
│         └─ Return output_window_length, output_channels                     │
│                                                                              │
│     STEP 4: Send ACK [cortex_adapter_send_ack_with_dims()]                  │
│     ├─ output_window_length_samples (W_out from cortex_init result)          │
│     └─ output_channels (C_out from cortex_init result)                       │
│                                                                              │
│  4. PROCESSING LOOP (for each window)                                       │
│     │                                                                        │
│     ├─ cortex_protocol_recv_window_chunked()                                │
│     │  ├─ Accumulate WINDOW_CHUNK frames by offset                          │
│     │  ├─ Validate: sequence matches, no gaps, completeness                 │
│     │  ├─ When CORTEX_CHUNK_FLAG_LAST received:                             │
│     │  │  └─ tin = get_timestamp_ns() [device clock]                        │
│     │  └─ Return reassembled window (host format float32)                    │
│     │                                                                        │
│     ├─ tstart = get_timestamp_ns() [before kernel]                          │
│     ├─ cortex_process(kernel_handle, input, output)                         │
│     │  └─ [NO ALLOCATION, NO I/O, NANOSECOND-LEVEL TIMING]                  │
│     ├─ tend = get_timestamp_ns() [after kernel]                             │
│     │                                                                        │
│     ├─ cortex_adapter_send_result()                                         │
│     │  ├─ tfirst_tx = get_timestamp_ns() [before send]                      │
│     │  ├─ Build RESULT payload:                                             │
│     │  │  ├─ session_id, sequence (validate continuity)                     │
│     │  │  ├─ tin, tstart, tend [device-side timing, nanoseconds]            │
│     │  │  ├─ output_samples (convert to little-endian)                      │
│     │  │  ├─ output_length, output_channels                                 │
│     │  │  └─ Compute CRC32                                                  │
│     │  ├─ transport.send() [atomic]                                         │
│     │  └─ tlast_tx = get_timestamp_ns() [after send]                        │
│     │                                                                        │
│     └─ Repeat (or exit if EOF on stdin)                                     │
│                                                                              │
│  5. CLEANUP (signal or EOF)                                                 │
│     ├─ cortex_teardown(kernel_handle)                                       │
│     ├─ dlclose(dl_handle)                                                    │
│     ├─ free(calibration_state)                                              │
│     └─ exit(0)                                                               │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘

================================================================================
                       DATA FLOW: REMOTE EXECUTION (TCP)
================================================================================

User Input:
  $ cortex run --kernel car --deploy ssh://nvidia@jetson

┌──────────────────────────────────────────────────────────────────────────────┐
│ DEPLOYMENT PHASE (Python, src/cortex/deploy/)                               │
│                                                                              │
│  1. SSHDeployer.detect_capabilities()                                       │
│     ├─ Check passwordless SSH [lines 79-118]                                │
│     │  └─ If fails: print setup instructions (ssh-copy-id)                  │
│     └─ Run: uname -s, uname -m, which gcc make                              │
│                                                                              │
│  2. SSHDeployer.deploy()                                                     │
│     ├─ rsync source → ~/cortex-temp on device                               │
│     ├─ Remote build: ssh "cd ~/cortex-temp && make all"                     │
│     │  └─ Cross-compile for ARM64 (if needed)                               │
│     └─ Start daemon: ssh "~/cortex-temp/primitives/adapters/v1/native/...   │
│                           cortex_adapter_native tcp://:9000 &"               │
│        └─ Return DeploymentResult:                                          │
│           ├─ transport_uri = "tcp://jetson-ip:9000"                         │
│           ├─ adapter_pid = None (remote process)                            │
│           └─ metadata = {platform, arch, build_time, validation_status}     │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘
                                      │
                                [Network: TCP port 9000]
                                      │
                                      ▼
┌──────────────────────────────────────────────────────────────────────────────┐
│ HARNESS PHASE (after deployment)                                             │
│                                                                              │
│  device_comm_init(..., "tcp://jetson-ip:9000", ...)                         │
│  ├─ Parse URI → scheme="tcp", host="jetson-ip", port=9000                  │
│  ├─ cortex_transport_tcp_client_create(host, port, timeout=5s)              │
│  │  ├─ getaddrinfo(host, port)                                              │
│  │  ├─ socket(AF_INET, SOCK_STREAM)                                         │
│  │  ├─ connect(host, port) [blocks until connected]                         │
│  │  └─ wrap in cortex_transport_t (send/recv/close/get_timestamp_ns)        │
│  │                                                                           │
│  └─ Proceed with normal handshake + execution loop (identical to local)     │
│     [WINDOW_CHUNK frames transmitted over TCP]                              │
│     [RESULT frames received over TCP]                                        │
│                                                                              │
│  Cleanup:                                                                    │
│  ├─ Close TCP connection (adapter detects close)                            │
│  ├─ SSHDeployer.cleanup()                                                   │
│  │  ├─ Kill remote adapter: ssh "pkill cortex_adapter_native"              │
│  │  └─ Remove ~/cortex-temp: ssh "rm -rf ~/cortex-temp"                    │
│  └─ Generate results                                                         │
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘

================================================================================
                          PROTOCOL FRAME STRUCTURE
================================================================================

All frames follow this format (little-endian wire encoding):

┌──────────────────────────────────────────────────────────────────────────────┐
│ FRAME HEADER (16 bytes, little-endian)                                       │
├──────────────────────────────────────────────────────────────────────────────┤
│ Offset  Size  Field          Value/Purpose                                  │
│ 0       4     magic          0x43525458 ("CRTX" little-endian)              │
│ 4       1     version        1 (protocol version)                            │
│ 5       1     frame_type     HELLO(1), CONFIG(2), ACK(3), WINDOW_CHUNK(4), │
│                              RESULT(5), ERROR(6)                            │
│ 6       2     flags          0 (reserved)                                    │
│ 8       4     payload_length Payload size in bytes                           │
│ 12      4     crc32          CRC over [0:12] + payload                      │
├──────────────────────────────────────────────────────────────────────────────┤
│ PAYLOAD (variable length, little-endian)                                     │
│ Depends on frame_type (see cortex_wire.h for struct definitions)             │
└──────────────────────────────────────────────────────────────────────────────┘

EXAMPLE: WINDOW_CHUNK Frame (40KB window split into 5×8KB chunks)

┌─────────────────────────────────────────────────────────────────┐
│ Chunk 1 (offset 0)                                              │
├─────────────────────────────────────────────────────────────────┤
│ WINDOW_CHUNK Payload:                                           │
│   sequence (u32_le)              = 42                           │
│   total_bytes (u32_le)           = 40960                        │
│   offset_bytes (u32_le)          = 0                            │
│   chunk_length (u32_le)          = 8192                         │
│   flags (u32_le)                 = 0                            │
│   [payload: 8192 bytes of float32 samples in little-endian]     │
└─────────────────────────────────────────────────────────────────┘
     ... [4 more identical chunks, final has flags = LAST] ...
┌─────────────────────────────────────────────────────────────────┐
│ Chunk 5 (offset 32768)                                          │
├─────────────────────────────────────────────────────────────────┤
│ WINDOW_CHUNK Payload:                                           │
│   sequence (u32_le)              = 42                           │
│   total_bytes (u32_le)           = 40960                        │
│   offset_bytes (u32_le)          = 32768                        │
│   chunk_length (u32_le)          = 8192                         │
│   flags (u32_le)                 = 1 (CORTEX_CHUNK_FLAG_LAST)   │
│   [payload: 8192 bytes of float32 samples in little-endian]     │
└─────────────────────────────────────────────────────────────────┘

When adapter receives the final chunk (flags & LAST):
  tin = get_timestamp_ns()  [input complete timestamp]

RESULT Frame Example:

┌──────────────────────────────────────────────────────────────────┐
│ RESULT Payload:                                                  │
├──────────────────────────────────────────────────────────────────┤
│ session_id (u32_le)              = 12345678  [from CONFIG]       │
│ sequence (u32_le)                = 42        [from WINDOW]       │
│ tin (u64_le)                     = 1000000000  [ns, after LAST]   │
│ tstart (u64_le)                  = 1000100000  [ns, before proc]  │
│ tend (u64_le)                    = 1000200000  [ns, after proc]   │
│ tfirst_tx (u64_le)               = 1000210000  [ns, before send]  │
│ tlast_tx (u64_le)                = 1000220000  [ns, after send]   │
│ output_length_samples (u32_le)   = 160                           │
│ output_channels (u32_le)         = 64                            │
│ [payload: 160×64×4 bytes = 40960 bytes output in little-endian]  │
└──────────────────────────────────────────────────────────────────┘

Timing Semantics:
  - tin - harness_send_start  = input latency (transport + reassembly)
  - tstart - tin              = buffering latency (wait for complete input)
  - tend - tstart             = kernel execution latency (CRITICAL)
  - tfirst_tx - tend          = kernel→output_buffer latency
  - tlast_tx - tfirst_tx      = output transmission latency

================================================================================
                         TRANSPORT ABSTRACTION STACK
================================================================================

All transports implement cortex_transport_api_t:

┌──────────────────────────────────────────────────────────────────┐
│ ssize_t (*send)(ctx, buf, len)                                   │
│   ├─ Mock (socketpair): write(fd, buf, len)                      │
│   ├─ TCP Client: send(socket, buf, len, 0)                       │
│   └─ UART: write(fd, buf, len) [with RTS/CTS flow control]       │
│                                                                   │
│ ssize_t (*recv)(ctx, buf, len, timeout_ms)                       │
│   ├─ Mock (socketpair): poll() + read()                          │
│   ├─ TCP Client: select() + recv()                               │
│   └─ UART: poll() + read()                                       │
│                                                                   │
│ void (*close)(ctx)                                               │
│   ├─ Mock: close(fd)                                             │
│   ├─ TCP: shutdown() + close(socket)                             │
│   └─ UART: tcsetattr() + close(fd)                               │
│                                                                   │
│ uint64_t (*get_timestamp_ns)(void)                               │
│   ├─ POSIX: clock_gettime(CLOCK_MONOTONIC) [all except STM32]    │
│   └─ STM32: DWT->CYCCNT * (1e9 / cpu_hz) [not yet implemented]   │
└──────────────────────────────────────────────────────────────────┘

Transport Selection via URI:

  local://                  → Mock (socketpair)           [PRODUCTION]
  tcp://host:port           → TCP Client (harness)       [PRODUCTION]
  tcp://:port               → TCP Server (adapter)       [IMPLEMENTED]
  serial:///dev/ttyUSB0     → UART/Serial (POSIX)        [SLOW: 11 KB/s]

Bandwidth Characteristics:

  Socketpair (local://)     ~  50 µs round-trip
  TCP (tcp://host)          ~ 1-5 ms round-trip (network-dependent)
  Serial (serial://)        ~ 90 µs per byte @ 115200 baud = 11 KB/s total

Typical Window Transmission (160×64 float32 = 40,960 bytes):

  Socketpair:  ~2 ms (send 5×8KB chunks, poll() between)
  TCP:         ~5-50 ms (depends on network, MTU 1500 bytes)
  Serial:      ~3.7 seconds @ 115200 baud (too slow for BCI!)

================================================================================
                           COMPONENT INTEGRATION MAP
================================================================================

Harness Execution Flow:

  src/cortex/commands/run.py
      ├─ Parse args (--kernel car, --deploy ssh://...)
      ├─ Create deployer if needed
      ├─ deployer.deploy() → DeploymentResult
      │   └─ transport_uri = "tcp://jetson:9000"
      │
      └─ src/engine/harness/app/
          ├─ Load config (cortex.yaml)
          ├─ device_comm_init(transport_uri, ...)
          │   ├─ Parse URI → select transport
          │   ├─ Handshake (atomic, synchronous)
          │   │   ├─ recv_hello()
          │   │   ├─ send_config()
          │   │   └─ recv_ack()
          │   └─ Return device handle + metadata
          │
          ├─ Replayer feeds windows
          │   └─ For each hop:
          │       └─ device_comm_execute_window()
          │           ├─ send_window_chunked()
          │           ├─ recv_result()
          │           └─ Store timing + output
          │
          └─ device_comm_teardown()
              ├─ Close transport
              ├─ deployer.cleanup() [if remote]
              └─ Generate results

Adapter Execution Flow:

  primitives/adapters/v1/native/adapter.c:main()
      ├─ cortex_adapter_transport_create(config_uri)
      │   └─ "local://" → stdin/stdout FDs
      │       (pre-connected by harness fork/dup2)
      │
      └─ run_session() [lines 237+]
          ├─ send_hello()
          │   └─ cortex_adapter_send_hello()
          ├─ recv_config()
          │   └─ cortex_adapter_recv_config()
          ├─ load_kernel_plugin() [lines 102-215]
          │   ├─ Parse spec_uri
          │   ├─ dlopen(lib_path)
          │   ├─ Detect ABI version
          │   └─ cortex_init(&config)
          ├─ send_ack()
          │   └─ cortex_adapter_send_ack_with_dims()
          │
          └─ Processing loop:
              ├─ recv_window_chunked()
              ├─ Measure: tin, tstart, tend
              ├─ cortex_process(kernel, input, output)
              ├─ send_result()
              │   └─ cortex_adapter_send_result()
              │       ├─ Measure: tfirst_tx, tlast_tx
              │       └─ Transmit output + timing
              └─ Repeat until EOF

================================================================================
                        ERROR HANDLING & RECOVERY
================================================================================

Error Codes (cortex_wire.h):

  CORTEX_ETIMEDOUT          (-1000)  Transport timeout
  CORTEX_ECONNRESET         (-1001)  Connection closed
  CORTEX_EPROTO_MAGIC_NOT_FOUND       Frame header corruption
  CORTEX_EPROTO_CRC_MISMATCH          CRC verification failed
  CORTEX_EPROTO_VERSION_MISMATCH      Protocol version mismatch
  CORTEX_EPROTO_FRAME_TOO_LARGE       Payload exceeds 64KB
  CORTEX_ECHUNK_SEQUENCE_MISMATCH     Window sequence out of order
  CORTEX_ECHUNK_INCOMPLETE            Missing chunks (gaps)
  CORTEX_ECHUNK_BUFFER_TOO_SMALL      Output buffer too small

Session Tracking (Restart Detection):

  session_id (random, generated in CONFIG)
    ├─ Returned in each RESULT frame
    └─ Mismatch indicates adapter restart [device_comm.c:629]

  sequence (incremented per window)
    ├─ Returned in each RESULT frame
    └─ Mismatch indicates out-of-order frames [device_comm.c:634]

Timeouts (cortex_wire.h):

  CORTEX_HANDSHAKE_TIMEOUT_MS  5000 ms  HELLO, CONFIG, ACK
  CORTEX_WINDOW_TIMEOUT_MS     10000 ms WINDOW_CHUNK + RESULT
  CORTEX_CHUNK_TIMEOUT_MS      1000 ms  Individual chunk reception
  CORTEX_ACCEPT_TIMEOUT_MS     30000 ms TCP server accept (network)

Graceful Shutdown:

  Signal Handler (adapter.c:35-41):
    SIGINT/SIGTERM → g_shutdown = 1
      ├─ Break from processing loop
      ├─ cortex_teardown(kernel_handle)
      ├─ dlclose(dl_handle)
      └─ exit(0)

  EOF Detection (harness):
    transport.recv() → 0 bytes (EOF)
      ├─ device_comm_teardown()
      ├─ deployer.cleanup()
      └─ Generate results

================================================================================

SUMMARY: Three-layer abstraction enables distributed kernel execution
         with pluggable transports, frozen ABI, and nanosecond-level timing.

